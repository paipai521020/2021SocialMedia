疾病传染模型

本文将简单疾病在人类、动物、植物甚至计算机之间的接触网络中传播的流行过程理论。

# 一、简介

在流行病中，疾病在人群中广泛传播。该过程包括病原体（正在传播的疾病）、宿主群体（人类、动物和植物等）和传播机制（呼吸、饮酒、性活动等）。 与信息级联和羊群不同，但与创新模型的扩散相似，流行病模型假设个体之间存在隐式网络和未知联系。这使得流行病模型更适合当我们对全球模式感兴趣时，例如感染人数的趋势和比率， 而不是谁感染谁。

# 二、常见传染病

疾病通过人与人之间的接触网络传播：当两个人在同一个房间呼吸空气时，流感或肺结核等空气传播疾病就会传播；当人们接触时，可以传播传染病和寄生虫；人们在发生性行为时会传播艾滋病毒和其他性传播疾病。这种联系的模式可以表示为网络，并且已经投入大量精力对这些网络结构进行实证研究。

一般来说，全面了解流行病过程需要对每个宿主内的生物过程和免疫系统过程有大量了解，以及对个体之间相互作用的综合分析。 社会和文化属性等其他因素也在流行病发生的方式、时间和地点方面发挥作用。 大型流行病，也称为大流行病，已经在人类中传播，包括 13 世纪的黑死病（杀死了欧洲 50% 以上的人口）、伦敦大瘟疫（10 万人死亡）、17 世纪的天花流行病 世纪（杀死 90% 以上的马萨诸塞湾美洲原住民）和最近的流行病，如 HIV/AIDS、SARS、H5N1（禽流感）和流感。 这些推动了 20 世纪初流行病模型的引入和流行病学领域的建立。

# 三、建模方式

有多种建模流行病的方法。例如，人们可以查看主机如何相互联系，并设计描述网络中流行病如何发生的方法。 这些网络称为接触网络。 联系网络是一个图，其中节点代表主机，边代表这些主机之间的交互。 例如，在 HIV/AIDS 流行的情况下，边代表性互动，而在流感的情况下，连接的节点代表呼吸相同空气的宿主。 就现实世界的接近度而言，接触网络中靠近的节点不一定很靠近。对于植物或动物来说，现实世界的接近度可能是正确的，但由于宿主的传播模式，SARS 或禽流感等疾病会在各大洲之间传播。当使用流行病科学来了解计算机病毒在手机网络或互联网上的传播时，这种传播模式变得更加清晰。

查看流行病模型的另一种方法是避免考虑网络信息，只分析主机被感染、恢复等的速率。 这种分析被称为完全混合技术，假设每个主机与其他主机相遇的机会均等。 通过这些交互，主机具有随机感染的概率。尽管很简单，但该技术揭示了几种有用的流行病建模方法，这些方法通常能够描述各种现实世界的爆发。 在文中，我们专注于避免使用接触网络的完全混合模型。

信息传播模型或多或少与流行病模型相关。然而，流行病模型的不同之处在于，在其他信息传播模型中，参与者决定是采用创新还是做出决定，并且系统通常是完全可观察的。 然而，在流行病中，系统具有高度的不确定性，个人通常不会决定是否被感染。传染病模型的模型假设 (1) 没有可用的联系网络信息，以及 (2) 主机被感染的过程未知。 这些模型可以应用于社交媒体中的情况，在这些情况下，决策过程具有一定的不确定性或对分析师来说是模棱两可的。

# 四、内涵

由于没有网络，我们假设我们有一个正在传播疾病的人群。 让 N 定义这个人群的规模。 人群中的任何成员都可以处于以下三种状态之一：

### 1.易感：
当一个人处于易感状态时，他或她有可能被疾病感染。实际上，感染可能来自疾病正在传播的人群之外（例如，通过基因突变、与动物接触等）；然而，为了简单起见，我们做了一个封闭世界的假设，其中易感个体只能被人群中的感染者感染。我们将时间 t 的易感者数量表示为 S(t) 和分数 $ s(t) = S(t)/N $ 的易感人群。 

### 2.感染者：
被感染者有机会感染易感者。让 I(t) 表示在时间 t 感染的个体数量，让 i(t) 表示被感染个体的比例，$ i(t) = I(t)/N $。

### 3.康复（或移除）：
这些人要么已经从疾病中康复，因此对感染具有完全或部分免疫力，要么被感染杀死。让 R(t) 表示该集合在时间 t 的大小，而 r(t) 表示恢复的分数，r(t) = R(t)/N 。显然，对于所有 t，$ N = S(t) + I(t) + R(t) $。 由于我们假设 S(t)、I(t) 和 R(t) 的值存在一定程度的随机性，因此我们尝试处理期望值并假设 S、I 和 R 在 时间 t。

# 五、经典传染病模型简介

### 1.SI模型
在这个模型中，易感个体会被感染，一旦被感染，他们将永远无法治愈。 将 β 表示为接触概率。 换句话说，一对人在任何时间步长相遇的概率都是β。 因此，如果 β = 1，则每个人都与其他人接触，如果 β = 0，则没有人会遇到另一个人。 假设当受感染的个体遇到易感个体时，疾病以概率 1 传播（这可以推广到其他值）。图 1 展示了 SI 模型以及在该模型中发生的个体状态之间的转换。 箭头上的值表明每个易感个体在下一个时间步中至少遇到 β I 感染个体。
 图1.SI模型 (figure/SI模型.PNG)
 
### 2.SIR模型
SIR 模型为标准 SI 模型添加了更多细节。 在 SIR 模型中，除了 I 和 S 状态外，还存在恢复状态 R。 图 7.12 描述了该模型。在 SIR 模型中，主机被感染，保持感染一段时间，然后恢复。 一旦主机恢复（或被移除），它们就不会再受到感染，也不再容易受到感染。 易感个体被感染的过程类似于 SI 模型，其中参数 β 定义了与他人接触的概率。 类似地，SIR 模型中的参数 γ 定义了感染者如何康复，或感染者在时间段 t 内的康复概率。
 图2.SIR模型 (figure/SIR模型.PNG)
 
### 3.SIRS模型
SIS 模型与 SI 模型相同，增加了恢复并再次变得易受感染的节点。
 图3.SIRS模型 (figure/SIRS模型.PNG)
 
#  六、干预措施

在任何大流行或流行病爆发中，一个紧迫的问题是如何停止这一过程。我们根据 Nicholas A. Christakis [2004] 的最新发现讨论流行病干预。在任何流行病爆发中，受感染的个体都会感染易感个体。实际发生的情况与模型大不相同。受感染的个人接触者数量有限，只有在这些接触者易感时才能感染他们。与没有接触者的人相比，人脉广泛的感染者对流行病爆发的危害更大。换句话说，流行病发生在一个网络中。不幸的是，通常很难追踪这些联系人并勾勒出联系人网络。如果可以的话，干预疫情爆发的最好办法，就是在高度连接的节点上接种疫苗，阻止疫情。这将导致所谓的群体免疫，并将阻止流行病的爆发。群体免疫需要对群体内的群体进行疫苗接种，这样病原体就不会在群体内引发爆发。一般来说，建立群体免疫至少需要随机抽取 96% 的人口样本进行疫苗接种。有趣的是，我们可以通过利用网络中的朋友来实现相同的群体免疫。一般来说，人们知道他们的哪个朋友有更多的朋友。因此，他们知道或可以访问这些更高程度和更多连接的节点。 Christakis 发现，如果随机选择 30% 的群体，然后向这 30% 的人询问他们最高级别的朋友，则可以通过为这些朋友接种疫苗来实现群体免疫。当然，旧的干预技术，例如将感染者与易感者分开（隔离）或清除感染者（杀死患有疯牛病的奶牛）仍然有效。

# 七、示例

古代医疗条件不发达、不懂得对病人进行防疫隔离时，发生恶性瘟疫的情形。
我们设置每个病人、每天传染的人数的常数t，分别为0.3和0.25， 设置初期只有1个病人，来看看模拟的传染人数。从下图可以看到，自由增长模型整体.上呈现指数增长趋势，对参数t非常敏感。

代码实现：
'''{r}
install.packages("deSolve")
library(deSolve)
rm(list=ls())
s_equations <- function(time , variables , parameters){
  with(as.list(c(variables,parameters)),{
    dI <- rio*I
    return(list(c(dI)))
  })
}
#设置病人数的初始值为1个病人
initial_values <- c(
  I=1
)
#设置病情发展的时间为20天
time_values <- seq(0,20)
#设置参数值0.3
parameters_values <- c(
  rio = 0.3
)
s_values_1 <- ode (
  y = initial_values,
  times = time_values,
  func = s_equations,
  parms = parameters_values
)
s_values_1 <- as.data.frame(s_values_1)
#设置参数值0.25
parameters_values <- c(
  rio=0.25
)
s_values_2 <- ode (
  y = initial_values,
  times = time_values,
  func = s_equations,
  parms = parameters_values
)
s_values_2 <- as.data.frame(s_values_2)
#作图
with(s_values_1,{
  plot(time,I,type = "b",col = "blue",main="自由增长模型" ,ylab = "Infected")
})
with(s_values_2,{
  lines(time,I,type = "b",col = "black")
})
legend("top",c("rio = 0.3", "rio = 0.25"),
       col = c("blue", "black"), lty = 1, bty = "n")
'''

输出结果：见自由增长模型.PNG (figure/见自由增长模型.PNG)
